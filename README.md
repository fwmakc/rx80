# RX-80

8-битный фэнтези ретро компьютер.

Использует архитектуру семейства процессоров x80, таких как Intel 8080, Intel 8086, Motorolla 68000, Zilog z80.

Буква R в названии обозначает Retro. Символы X-80 служат для обозначения архитектуры.

Создан на базе https://github.com/fwmakc/rx8/ как дальнейшее развитие платформы.

# Псевдоистория

Здесь мы будем размышлять о создании фэнтези-процессора как о возможном развитии семейства процессоров x80.

Так, Intel создала процессор 8086 и перешла на 16-битную архитектуру. Мы же будем создавать свой процессор x80 как следующую ступень развития 8-битной архитектуры.

Свой процессор мы так и назовем - "x80".

# Процессор

Мы берем за основу процессор z80, как наиболее интересное развитие семейства процессоров архитектуры x80.

Наши 8-битная архитектура:

- регистры 8 бит (могут объединяться в 16 бит)
- шина данных 8 бит
- шина адреса 16 бит (до 64 кБ памяти)

Для этой части мы пока что взяли за основу описание процессора i8086 из статьи https://habr.com/ru/articles/902412/.

Таким образом, мы получили некий эталон характеристик, которые в дальшейшем будем менять в сторону упрощения к 8-битной архитектуре.

Дополняем описанием процессора z80 с ресурса https://zx-pk.ru/ и книг издательства Инфорком.

Вот эти предварительные характеристики.

## Память

Память

Адресный диапазон | Назначение | Комментарий
00000h - 003FFh | Interrupt Vector Table | Таблица векторов прерываний. Номера векторов от 0 до FFhex (255dec)
00400h – 9FFFFh | Conventional Memory | Оперативная память для программ и данных
A0000h – BFFFFh | Video Memory | Графика (CGА/EGA/VGA), текстовый режим
C0000h – DFFFFh | Расширенная видеопамять | BIOS видеокарт, сетевых карт и т.п.
E0000h – FFFFFh | System / BIOS ROM | Постоянная память BIOS

### Память 128 кБ

#### 1

Кратко об устройстве памяти в SINCLAIR 128

128я память организована страничным образом.

Начиная с адреса #c000 (49152) длинною #4000 (16384) находится область, в которую можно включить другую страницу. Этим заведует порт #7ffd (32765), он стандартен для всех 128к машин.

#### 2

ZX Spectrum 128K не имеет отдельной 128-килобайтной памяти в привычном понимании. Вместо этого, он использует аппаратный переключатель страниц памяти, который позволяет динамически выделять дополнительную память для процессора и видеопамяти из общего пула в 128 КБ. Система использует 16 КБ для оперативной памяти, а остальные 112 КБ выделяются для программ и данных. 

Как это работает:

1. Память как единый пул:
Вся память в 128 КБ рассматривается как единый пул, из которого система выделяет нужные ресурсы.

2. Переключение страниц:
Процессор Zilog Z80, используемый в Spectrum, может переключать "страницы" памяти. Это позволяет ему видеть разные сегменты памяти как часть своего адресного пространства.

3. Выделение памяти:
16 КБ RAM: Эта область всегда доступна для работы программы.
112 КБ для данных и программ: Оставшаяся память может быть выделена для хранения больших программ, данных, а также видеопамяти (памяти для графики).

4. Аппаратное управление:
Переключение страниц осуществляется аппаратно, позволяя программе получить доступ к разным блокам памяти по мере необходимости.

5. Преимущества:
Благодаря такому механизму, ZX Spectrum 128K мог работать с более крупными программами и более сложными графическими режимами, чем 48-килобайтные модели.

#### 3

```
Компьютер SINCLAIR 128 имеет озу объемом 128 К, которое разделено на
8 банков памяти по 16 килобайт и которые условно нумеруются от 0 до 7.
В системе имеется регистр конфигурации, который доступен програмистоу
и имеет адрес 7FFDH. С помощью записи в этот регистр мы  можем менять
конфигурацию системы  т.е. переключать ПЗУ, банки ОЗУ и т.д.. Регистр
конфигурации имеет 6 разрядов. Первые три  ( с 0-го по 2-й )  разряда
определяют один из восьми банков банков, подлюченный в последний сек-
тор адресного пространства процессора.  3-й  определяет один  из  2-х
банков, который будет подлючен в первый сектор адресного пространства
и отображен на экран: 0 - подключен 5-й  банк, 1 - подключен 7-й банк.
4-й  разряд  определяет  ПЗУ:  0 - подключена прошивка BASIC 128, 1 -
BASIC 48. 5-й разряд заведует блокировкой записи в регистр конфигура-
ции:  0 - запись  разрешена,  1 - запись блокированна. Это необходимо
для работы в режиме SINCLAIR 48.

  АДРЕС Z-80         СЕКТОР                             ПЗУ 32К
                ---------------¬                    --------------¬
  0000-3FFF     ¦     16K      ¦ ___¦0 в разряде 4--+BASIC 128 16K¦
                ¦  0-й сектор  ¦    ¦1 в разряде 4--+BASIC 48  16K¦
                +--------------+                    L--------------
  4000-7FFF     ¦     16K      ¦ ___                    ОЗУ 128К
                ¦  1-й сектор  ¦    ¦1 в разряде 3--+7-й БАНК 16К ¦
                +--------------+    ¦               ¦6-й БАНК 16К ¦
  8000-BFFF     ¦     16К      ¦    ¦0 в разряде 3--+5-й БАНК 16К ¦
                ¦  2-й сектор  ¦                    ¦4-й БАНК 16К ¦
                +--------------+                    ¦3-й БАНК 16К ¦
  C000-FFFF     ¦     16К      ¦--------------------¦2-й БАНК 16К ¦
                ¦  3-й сектор  ¦     любой из       ¦1-й БАНК 16К ¦
                L---------------     8-ми           ¦0-й БАНК 16К ¦
                                     БАНКОВ ОЗУ     L--------------
                          000 в разрядах 2 - 0 - 0-й БАНК
                          001 ------------------ 1-й БАНК
                          ...............................
                          111 ------------------ 7-й БАНК
```

В первый сектор ничего не включается. он всегда на своем месте. и он равнозначен банку 5. т.е. если мы включем банк 5 и запишем в #c000 число, то реально оно будет доступно и по #4000. т.е. это одна и та же страница. но вот банк 7 со вторым экраном с областью #4000..#7fff никак не пересекаются.

Как (на примере) переключать страницы:

```
ld bc,#7ffd ; порт
ld a,1 ; 1й банк
or #10 ; пзу 48к
out (c),a ; переключить!
```

после этого в диапазоне #c000..#ffff будет выбранный банк.

если это юзать из бейсика, то надо зайти сначала в бейсик 128, выполнить там usr 0, сброситься в 48й бейсик, сделать clear XXX (где XXX<49152), и затем уже можно переключать страницы с помощью out 32765,Y+16 (где Y=номеру банка).

попробуйте сделать out 32765,5+16 и потом что-нить менять в адресах #c000..#daff.

или out 32765,7+16, потом загрузить картинку по адресу 49152, потом выполнить out 32765,7+16+8.

#### 4

Как следует из сказанного выше, общий объем памяти в 128 модели
достиг 160К, процессор же непосредственно может адресовать только 64К
из них. Выход из этого положения был найден сравнительно легко — через
механизм страничной адресации памяти. Адресное пространство процессора
было разделено на четыре равных раздела по 16К (иногда их называют
окнами), мы будем обозначать их CPU0...CPU3. Раздел CPU0 занимает адреса
0...#3FFF, CPU1 — #4000...#7FFF, CPU2 — #8000...#BFFF и CPU3 — #C000...#FFFF.
Вся память также была разделена на сегменты по 16К,
называемые еще банками памяти, или страницами памяти. Мы будем обоз-
начать банки ПЗУ через ROMO и ROM1, а банки ОЗУ от RAM0 до RAM7.
Через специальный механизм (который мы рассмотрим ниже) программист
может по своему усмотрению устанавливать в адресные разделы микропро-
цессора те или иные банки памяти. На рис. 15 показано, какая память где
может находиться.

Банк ROMO содержит расширение интерпретатора языка Бейсик,
встроенного в компьютер, написанное специально для 128 модели, а содер-
жимое ROM1 практически полностью совпадает с ПЗУ из стандартного ZX
Spectrum. Находиться эти банки могут только в адресном разделе микропро-
цессора CPU0. Разделам CPU1 и CPU2 соответствуют фиксированные банки
ОЗУ, RAM2 и RAM5 соответственно. В разделе CPU3 можно установить
любой из банков ОЗУ.

Механизм страничной адресации памяти, а также музыкальный про-
цессор и иная организация принтера потребовал расширения стандартных
внешних устройств, обрабатываемых «внутри» компьютера. Выше писалось,
что выбор устройств в ZX Spectrum осуществляется сбросом в ноль какого-
либо разряда шины адреса. Для ZX Spectrum 128 это верно только наполо-
вину. Действительно, для обращения к дополнительным портам в младших
восьми разрядах устанавливается в ноль адрес А1. Таким образом, общий
адрес внешних устройств должен быть #FD. Выбор же конкретного устрой-
ства определяют адреса А14 и А15.

Порт 32765 l#7FFD, %1111111111111101)

Отдельными битами этого порта осуществляется управление конфи-
гурацией компьютера. Отметим, что этот порт доступен только для записи,
поэтому интерпретатор Бейсика в системных переменных по адресу 23388
(#5В5С) хранит копию этого регистра:

биты 0...2 определеяют номер страницы ОЗУ, установленной в адресном
разделе CPU3 микропроцессора:

000 (0) - RAM0

001 (1) - RAMI

010 (2) - RAM2

011 (3) - RAM3

100 (4) - RAM4

101 (5) - RAM5

110 (6) - RAM6

111 (7) - RAM7

бит 3 управляет режимом отображения информации, точнее, номером
видеостраницы, содержимое которой выводигся на монитор. Если бит
сброшен, то на дисплей выводятся значения из стандартной экранной
области памяти, расположенной в адресах #4000...#5AFF (банк
RAM5). Если же бит установлен, то отображаются данные из второй
видеостраницы, находящейся в банке RAM7. Обратите внимание, что
такое решение позволяет полностью исключить «видеопамять» из
адресного пространства микропроцессора и подключать ее по мере
необходимости, тогда как изображение на экране будет выводиться
постоянно;

бит 4 определяет содержимое адресного раздела микропроцессора CPU0.
Если бит сброшен, то адресуется банк ROMO, содержащий коды
расширения интерпретатора Бейсика; если бит установлен, в адресах

*) Более подробно об этом можно прочитать в книге «Диалекты Бейсика для
ZX Spectrum».

0...#3FFF будет находиться банк ROM1, где хранится практически не
измененная копия обычного ПЗУ Speccy.
бит 5 управляет режимом совместимости с обычным ZX Spectrum, уста-
новка этого бита приведет к отключению дополнительной памяти,
таким образом, компьютер практически полностью превратится в
старый добрый Speccy. Отметим, что сбросить значение этого бита
программным путем невозможно, необходим аппаратный «сброс»
всего компьютера.

Остальные биты из этого порта не используются.

Порт 49149 (#BFFD, %1011111111111101)
Порт 65533 (#FFFD, %1111111111111101)

Через эти порты осуществляется адресация восьмиразрядных регист-
ров музыкального процессора. Всего таких регистров шестнадцать, мы будем
обозначать их R0...R15. Регистры двунаправленные, то есть информацию в
них можно записывать и считывать. Для доступа к какому-либо регистру его
номер (число в диапазоне от 0 до 15) необходимо записать по адресу 65533.
После этого становится возможна передача данных между этим «установлен-
ным» или текущим регистром и микропроцессором. Для смены текущего
регистра соответствующий номер нужно записать в порт 65533, и так далее.

Обратите внимание, что адреса для чтения и записи информации в
текущий регистр музыкального процессора различны. Для записи байта
нужно выполнить команду вывода в порт с адресом 49149, а для чтения —
команду ввода из порта с адресом 65533.

Прежде чем разобрать функции отдельных регистров музыкального
процессора, остановимся на его особенностях. Микросхема музыкального
процессора имеет три независимых канала для формирования звука (обоз-
начаются А, В и С) и два двунапрвленных восьмиразрядных канала вво-
да/вывода — IRA и IRB, соответственно. Через канал IRA осуществляется
связь с принтером, вывод сигналов для специального музыкального интер-
фейса MIDI и, кроме этого, связь со специальной выносной клавиатурой
функциональных клавиш, используемых в расширенном интерпретаторе
Бейсика.

__Регистры RO/RI, R2/R3, R4/R5

Три спаренных регистра R0/R1, R2/R3, R4/R5 используются для вы-
работки частоты тона соответственно каналов А, В и С. Необходимые двенад-
цатиразрядные значения образуются из восьми бит младшего по номеру
регистра и четырех младших бит старшего по номеру регистра.

Регистр R6

Младшие пять разрядов этого регистра задают частоту шума.

Регистр R7

Через этот регистр осуществляется управление звуковыми каналами
и регистрами ввода/вывода:

биты 0...2 используются для управления выводом частоты тона. Установка
битов 0, 1 или 2 приведет к запрещению вывода частоты тона в
каналы А, В и С соответственно;
биты 3...5 используются для управления выводом частоты шума. Установ-
ка битов 3, 4 или 5 приведет к запрещению вывода частоты шума в
каналы А, В и С соответственно;
биты в и 7 устанавливают режим работы каналов IRB и IRA соответст-
венно. При сброшенном бите канал работает на ввод, а при установ-
ленном — на вывод информации.

Регистры R8, R9 и RfQ

Младшие пять разрядов регистров R8, R9 и R10 управляют соответст-
венно амплитудой каналов А, В и С.

Регистры R11/R12

Спаренные регистры RH/R12 образуют шестнадцатиразрядное зна-
чение огибающей выходного сигнала, регистр R11 несет младший байт, а

R12 — старший.

Регистр R13

Младшие четыре разряда этого регистра управляют формой и режи-
мом огибающей выходного сигнала:

бит 0 — затухание;
бит 1 — чередование;
бит 2 — нарастание;
бит 3 — продолжение.

Регистры R14 и R15

Регистры R14 и R15 используются соответственно для связи с канала-
ми ввода/вывода IRA и IRB. Содержимое этих регистров можно в любой
момент считывать и записывать, на формировании звука это никак не

отражается.

## Регистры

Сегментные регистры

Регистр | Назначение
CS | Code Segment - содержит адрес сегмента кода, в котором находятся выполняемые процессором инструкции.
DS | Data Segment - содержит адрес сегмента данных, к которым по-умолчанию обращается большинство инструкций при выполнении действий с данными в памяти.
SS | Stack Segment - содержит адрес сегмента стека, который используется для хранения данных стека.
ES | Extra Segment - дополнительный сегмент данных.

Регистры общего назначения

Регистр | Имя | Назначение
AX | Accumulator register | Аккумулятор для арифметики
BX | Base register | Базовый указатель на данные
CX | Counter register | Счётчик для циклов и сдвигов
DX | Data register | Используется в умножении и делении вместе с AX и при обмене данными с периферийными устройствами

Регистры AX, BX, CX, DX разбиваются на пары 8-битных регистров:

Регистр | High (биты 16 .. 8) | Low (биты 7 .. 0)
AX | AH | AL
BX | BH | BL
CX | CH | CL
DX | DH | DL

То есть, можно работать как с полным 16-битным регистром, так и отдельно, с его младшей и старшей частью.

Специальные регистры

Регистр | Имя | Назначение
SP | Stack pointer | Указатель стека (Stack Pointer) - нужен для работы механизма вызова процедур, обработчиков прерываний, инструкций PUSH/POP.
BP | Base pointer | Базовый указатель для работы со стеком (Base Pointer). Используется для доступа к памяти стека совместно с регистром SS.
SI | Source index | Индекс источника в строковых инструкциях, обрабатывающих массивы данных.
DI | Destination index | Индекс назначения в строковых инструкциях, обрабатывающих массивы данных.

Регистр-указатель инструкции IP (instruction pointer)

Регистр IP (instruction pointer) нельзя модифицировать или прочитать как регистр общего назначения.

В паре с регистром сегмента кода CS он используется для адресации инструкции, подлежащей исполнению. Регистр IP меняется при последовательном выполнении инструкций, каждый раз показывая на смещение инструкции, следующей за выполняемой в настоящий момент.

При выполнении инструкций условного или безусловного перехода Jx, JMP, инструкций вызова процедуры CALL, инструкций INT, RET, IRET, вызове аппаратного обработчика прерывания, и в некоторых других случаях, в IP загружается смещение целевого кода, куда нужно выполнить переход.

Регистр флагов (FLAGS)

№ бита | Имя флага | Функциональное назначение флага
0 | CF (Carry Flag) | Флаг переноса. Устанавливается, если последняя арифметическая операция перенесла (сложение) или заимствовала (вычитание) бит за пределы размера регистра. Этот флаг проверяется инструкциями сложения с переносом или вычитания с заёмом для обработки значений, слишком больших для одного регистра.
2 | PF (Parity Flag) | Флаг четности. Устанавливается, если количество установленных битов в младшем байте кратно 2.
4 | AF (Auxiliary Flag) | Дополнительный флаг переноса. Флаг вспомогательного переноса устанавливается, если во время сложения происходит перенос из младшего полубайта (младшие четыре бита) в старший полубайт (старшие четыре бита) или заём из старшего полубайта в младший полубайт во время вычитания. В противном случае, если такого переноса или заёма не происходит, флаг очищается. Этот флаг нужен для вычислений с двоично-десятичными числами (BCD).
6 | ZF (Zero Flag) | Флаг нуля. Устанавливается, если результат операции равен нулю.
7 | SF (Sign Flag) | Флаг знака. Устанавливается, если результат операции отрицательный (старший бит результата установлен).
8 | TF (Trap Flag) | Флаг ловушки. Устанавливается при пошаговой отладке.
9 | IF (Interruption Flag) | Флаг прерывания. Устанавливается, если процессору разрешено обрабатывать аппаратные прерывания.
10 | DF (Direction Flag) | Флаг направления. Направление потока. Если установлено, строковые операции будут уменьшать свой указатель, а не увеличивать его, считывая память в обратном направлении.
11 | OF (Overflow Flag) | Флаг переполнения. Устанавливается, если знаковые арифметические операции приводят к значению, слишком большому для регистра.

Аппаратные прерывания

Аппаратные прерывания — это сигналы от внешних или внутренних устройств процессору, которые требуют немедленного внимания.

Когда аппаратное устройство (например, таймер или клавиатура) хочет что-то сообщить процессору:

- Оно отправляет аппаратный сигнал прерывания
- Процессор временно приостанавливает выполнение текущей программы
- Переходит к обработчику прерывания (специальной программе)

Как это работает внутри

На системной плате с CPU есть контроллер прерываний, который определяет, какое именно устройство вызвало прерывание.

Каждый тип прерывания связан с уникальным номером (вектором), формируемым контроллером прерываний, и обработчиком в памяти.

Адрес обработчика прерывания вычисляется так:

Смещение обработчика = WORD PTR [Вектор × 4]

Квадратные скобки сообщают нам, что из ячейки памяти размером 1 слово (2 байта или 16 бит) с адресом Вектор × 4 нужно извлечь содержимое, тоже размером 1 слово, и уже его использовать как целевое смещение нужного нам объекта в памяти. В данном случае это будет смещение обработчика прерывания.

Сегмент обработчика = WORD PTR [(Вектор × 4) + 2]

Тот же самый смысл имеют квадратные скобки в случае сегмента: из ячейки памяти размером 1 слово с адресом (Вектор × 4) + 2 извлекаем содержимое и используем его как сегментный адрес обработчика прерывания.

Процедура извлечения из памяти адреса другого участка памяти называется "косвенная адресация". Если вы знакомы с программированием на C, то, возможно, сталкивались с разыменованием указателя. Вот это оно и есть.

При аппаратном прерывании процессор:

- Ждёт завершения текущей исполняемой инструкции
- Сохраняет в стек регистры FLAGS, CS, IP.
- Загружает адрес обработчика из таблицы векторов прерываний в CS:IP.
- Выполняет код обработчика.

После выполнения обработчика команда IRET (interrupt return) возвращает процессор к прерванной задаче, извлекая из стека регистры IP, CS, FLAGS.

Примеры аппаратных прерываний

Номер | Описание
INT 08h | Таймер. По-умолчанию обработчик вызывается каждые ~55 мс
INT 09h | Клавиатура
INT 0Ah-INT 0Fh | Прерывания других периферийных устройств (настраиваются через контроллер PIC)

Программные прерывания — это прерывания, которые инициируются самим кодом программы с помощью специальной инструкции INT.

То есть, мы можем принудительно "прервать" выполнение программы и вызвать системную функцию или собственный обработчик.

Как вызвать программное прерывание?

Очень просто:

```
INT вектор
```

Примеры программных прерываний

Инструкция | Назначение
INT 10h | Работа с видео (BIOS-функции для вывода текста и графики)
INT 13h | Доступ к дисковым устройствам (чтение/запись секторов)
INT 16h | Чтение клавиатуры
INT 21h | DOS-функции: ввод/вывод, работа с файлами

Что происходит при программном прерывании?

Когда процессор выполняет INT xx:

- Он делает примерно то же самое, что при аппаратном прерывании:
- Сохраняет FLAGS, CS, IP в стек.
- Загружает новый CS:IP из таблицы векторов прерываний по номеру прерывания.
- Выполняет код обработчика.

После выполнения обработчика команда IRET (interrupt return) возвращает процессор к прерванной задаче, извлекая из стека регистры IP, CS, FLAGS.

То есть, механизм тот же - отличается только источник сигнала.

## Интересное мнение

На самом деле у Z80 и i8080 только совместимая система команд, а внутри они устроены по разному, вплоть до того что АЛУ у Z80 4-х битное. Плюс Интелу в суде пришлось бы не просто доказывать факт копирования т.к. изменений по сравнению с 8080 было очень много начиная с:
1. Теневого набора регистров
2. Наличие индексных регистров и команд по работе с ними
3. Наличие команд оперирующими битами
4. Более развитая система прерываний
5. Регенерация динамической памяти
6. одно напряжение +5 вольт
7. более высокая производительность
8. возможность адресации 65536 портов ввода/вывода
9. Ассемблер Z80 полностью отличался от ассемблера 8080

А ещё были переходы с относительной адресацией… это было счастье! (когда программируешь в машинных кодах) ))

А еще не упомянули, что и по тактам он был быстрее. Например самую быструю команду MOV 8080 выполнял за 6 тактов, а Z80 за 4 такта, то есть он был еще быстрее чем просто по тактовой частоте считать. И это как-бэ намекает, что его архитектура «не была просто скопирована».

Система команд i8080 очень далека от совершенства, особенно, если рассматривать с точки зрения разработчика компиляторов с языков высокого уровня. По себе могу сказать, что условные возвраты и условные call'ы используются крайне редко. Очень не хватает инструкций смещения стека (add sp,), получения адреса переменной в стеке (lea hl,sp+), загрузка/запись из/в стек по указателю со смещением (ld a,(sp+)), индексации с переменным смещением (ld a,(hl+b)), а так же call hl. Лучше бы вместо условных возвратов, длинных джампов и коллов, они бы сделали: условный относительный переход на 1-9 байт вперед (смещение в коде инструкции), относительный переход на -128...+127, относительный переход на -32768...+32768, абсолютный переход, косвенный переход (на адрес в регистре), относительный call, абсолютный call, косвенный call, а так же инструкции загрузки регистров со смещением (пусть только положительным) относительно PC.
В процессоре gbz80 (который от z80 только мнемоники и таблицу cb имеет) ряд этих инструкций добавлен.
А вот z80 мало что унаследовал весь этот бардак (почему группу загрузок регистр-регистр нельзя было в начало опкодов поместить — тогда бы nop сама собой получилась, push af сохраняет аккумулятор как msb, но при этом он в остальных инструкциях имеет код 7, соответствующий младшему регистру в паре: ld a,a имеет код 0177). Плюс дополнил рядом бесполезных блочных инструкций. Кто-нибудь когда-нибудь использовал otdr и indr? А инструкция neg нахера нужна, когда есть cpl и inc a, исполняющиеся примерно за то же время?
Не так давно Zilog выпустила процессор с расширенным набором команд. Там появились инструкции LEA rr,ii+d и LD rr,(gg). Но Zilog не была бы сама собой, если бы не наворотила глупостей (имхо), например инструкция PEA ii+d (push effective address). Я так и не смог придумать ей полезного применения, а пишу под eZ80 с 2013 года (на z80 стаж с 1993, где-то). А вот реально нужных инструкций не добавилось…

В Z80 и сделали относительный переход +127 -128, и меньше двух байт его не сделаешь, а делать сверхкороткий относительный переход нет смысла из-за нерационального расхода оптокодов.
Необходимость относительного перехода -32768...+32768 вызывает сомнение т.к. 64 кб можно улететь не туда куда надо из-за арифметики.
Косвенный (короткий) вызов подпрограммы, теоретически возможен,, но на практике будет медленнее чем обычный вызов подпрограммы

# Ассемблер

Примеры основных команд ассемблера:

Арифметические команды:
- ADD (сложение): выполняет двоичную сумму двух операндов. 
- SUB (вычитание): вычисляет разность двух операндов. 
- MUL (умножение): выполняет беззнаковое умножение операндов. 
- DIV (деление): выполняет беззнаковое деление. 

Команды пересылки данных:
- MOV (пересылка): копирует данные из одного места (регистра или памяти) в другое. 
- XCHG (обмен): меняет местами содержимое двух операндов. 
- PUSH (положить в стек): помещает данные в стек. 
- POP (извлечь из стека): извлекает данные из стека. 

Логические команды:
- AND (логическое И): выполняет побитовое логическое "И" над операндами. 
- OR (логическое ИЛИ): выполняет побитовое логическое "ИЛИ". 
- EOR (исключающее ИЛИ): выполняет побитовое логическое "исключающее ИЛИ". 

Команды управления потоком:
- CALL (вызов процедуры): переходит к подпрограмме, сохраняя адрес возврата. 
- JMP (переход): безусловный переход к указанному адресу. 
- RET (возврат): возвращается из подпрограммы. 

Структура команды.

Каждая команда ассемблера обычно состоит из: 

- Мнемоники, короткое название команды, например, MOV или ADD.
- Операндов, данных, над которыми выполняется операция, например, регистров или значений.

Пример: ADD EAX, 10 – команда ADD складывает значение регистра EAX с константой 10. 

Еще:

https://blic.fandom.com/ru/wiki/%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%B8%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B5%D0%BD%D1%8C_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0

https://zxpress.ru/book_articles.php?id=1098

https://habr.com/ru/companies/ruvds/articles/646629/

# Шаблон

Шаблон для проектов:

- typescript,
- vite,
- eslint,
- prettier,
- electron.

# Начало работы

Создаем новую папку для проекта

```
mkdir my_project
cd my_project
```

Клонируем репозиторий

```
git clone https://github.com/fwmakc/ts-vite-project.git .
```

Устанавливаем

```
yarn
```

# Быстрый запуск

В режиме разработки

```
yarn dev
```

# Запуск под десктоп

В режиме разработки

```
yarn electron:dev
```

## Билд под десктопные устройства

Выполняем предварительную сборку

```
yarn build
```

Собираем приложение под десктоп

```
yarn electron:make
```

Готовое приложение будет лежать в каталоге

```
out/template-vite-ts-win32-x64
```

## Подготовка к сборке под мобильные устройства

Сборку делаем через capacitor. Полностью все происходит в несколько шагов.

Для настройки отредактируйте файл

```
capacitor.config.ts
```

Добавляем мобильное устройство. Это нужно сделать один раз после развертывания проекта.

```
yarn cap add android
```

Созданный каталог android содержит множество настроек приложения, которые хотелось бы сохранить в репозитории. Но он также содержит много временных файлов и копии проекта и поэтому получается слишком большим.

Мы создали другой каталог app, где вы можете хранить все настройки и ресурсы для сборки.

Перед сборкой вам просто нужно скопировать его содержимое

```
cp -rf app/android/* android/app/src/main
```

или

```
xcopy app\android\* android\app\src\main /E /H /C /I /Y
```

Выполняем предварительную сборку

```
yarn build
```

Копируем собранный проект для следующего этапа

```
yarn cap copy
```

## Билд под мобильные устройства

Для дальнейшей сборки под android лучше всего работать в контейнере nodejs из проекта https://github.com/isengine/server.git

Перейдем в каталог

```
cd android
```

Билд в режиме дебаг:

```
./gradlew assembleDebug
```

Готовое приложение будет лежать в каталоге

```
android/app/build/outputs/apk/debug/app-debug.apk
```

Билд в продакшн:

```
./gradlew assembleRelease
```

Готовое приложение теперь будет лежать в каталоге

```
android/app/build/outputs/apk/release/app-release-unsigned.apk
```

Дальнейшие действия лучше выполнять из корневого каталога проекта

```
cd ..
```

Создаем ключ для подписи

```
keytool -genkey -v -keystore MY_RELEASE_KEY.jks -keyalg RSA -keysize 2048 -validity 10000 -alias MY_KEY_ALIAS

```

Запишите созданные пароли и alias, так как они понадобятся вам в дальнейшем.

Создаем копию приложения

```
cp android/app/build/outputs/apk/release/app-release-unsigned.apk android/app/build/outputs/apk/release/app-release.apk
```

Подписываем приложение

```
apksigner sign --ks MY_RELEASE_KEY.jks --ks-key-alias MY_KEY_ALIAS --ks-pass pass:YOUR_KEYSTORE_PASSWORD --key-pass pass:YOUR_KEY_PASSWORD android/app/build/outputs/apk/release/app-release.apk
```

Можно проверить подпись

```
apksigner verify android/app/build/outputs/apk/release/app-release.apk
```

Если APK подписан правильно, вы не увидите никаких ошибок.

# Лицензия

Лицензия MIT, 2025
