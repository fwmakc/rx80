## Регистры

Сегментные регистры

Регистр | Назначение
CS | Code Segment - содержит адрес сегмента кода, в котором находятся выполняемые процессором инструкции.
DS | Data Segment - содержит адрес сегмента данных, к которым по-умолчанию обращается большинство инструкций при выполнении действий с данными в памяти.
SS | Stack Segment - содержит адрес сегмента стека, который используется для хранения данных стека.
ES | Extra Segment - дополнительный сегмент данных.

Регистры общего назначения

Регистр | Имя | Назначение
AX | Accumulator register | Аккумулятор для арифметики
BX | Base register | Базовый указатель на данные
CX | Counter register | Счётчик для циклов и сдвигов
DX | Data register | Используется в умножении и делении вместе с AX и при обмене данными с периферийными устройствами

Регистры AX, BX, CX, DX разбиваются на пары 8-битных регистров:

Регистр | High (биты 16 .. 8) | Low (биты 7 .. 0)
AX | AH | AL
BX | BH | BL
CX | CH | CL
DX | DH | DL

То есть, можно работать как с полным 16-битным регистром, так и отдельно, с его младшей и старшей частью.

Специальные регистры

Регистр | Имя | Назначение
SP | Stack pointer | Указатель стека (Stack Pointer) - нужен для работы механизма вызова процедур, обработчиков прерываний, инструкций PUSH/POP.
BP | Base pointer | Базовый указатель для работы со стеком (Base Pointer). Используется для доступа к памяти стека совместно с регистром SS.
SI | Source index | Индекс источника в строковых инструкциях, обрабатывающих массивы данных.
DI | Destination index | Индекс назначения в строковых инструкциях, обрабатывающих массивы данных.

Регистр-указатель инструкции IP (instruction pointer)

Регистр IP (instruction pointer) нельзя модифицировать или прочитать как регистр общего назначения.

В паре с регистром сегмента кода CS он используется для адресации инструкции, подлежащей исполнению. Регистр IP меняется при последовательном выполнении инструкций, каждый раз показывая на смещение инструкции, следующей за выполняемой в настоящий момент.

При выполнении инструкций условного или безусловного перехода Jx, JMP, инструкций вызова процедуры CALL, инструкций INT, RET, IRET, вызове аппаратного обработчика прерывания, и в некоторых других случаях, в IP загружается смещение целевого кода, куда нужно выполнить переход.

Регистр флагов (FLAGS)

№ бита | Имя флага | Функциональное назначение флага
0 | CF (Carry Flag) | Флаг переноса. Устанавливается, если последняя арифметическая операция перенесла (сложение) или заимствовала (вычитание) бит за пределы размера регистра. Этот флаг проверяется инструкциями сложения с переносом или вычитания с заёмом для обработки значений, слишком больших для одного регистра.
2 | PF (Parity Flag) | Флаг четности. Устанавливается, если количество установленных битов в младшем байте кратно 2.
4 | AF (Auxiliary Flag) | Дополнительный флаг переноса. Флаг вспомогательного переноса устанавливается, если во время сложения происходит перенос из младшего полубайта (младшие четыре бита) в старший полубайт (старшие четыре бита) или заём из старшего полубайта в младший полубайт во время вычитания. В противном случае, если такого переноса или заёма не происходит, флаг очищается. Этот флаг нужен для вычислений с двоично-десятичными числами (BCD).
6 | ZF (Zero Flag) | Флаг нуля. Устанавливается, если результат операции равен нулю.
7 | SF (Sign Flag) | Флаг знака. Устанавливается, если результат операции отрицательный (старший бит результата установлен).
8 | TF (Trap Flag) | Флаг ловушки. Устанавливается при пошаговой отладке.
9 | IF (Interruption Flag) | Флаг прерывания. Устанавливается, если процессору разрешено обрабатывать аппаратные прерывания.
10 | DF (Direction Flag) | Флаг направления. Направление потока. Если установлено, строковые операции будут уменьшать свой указатель, а не увеличивать его, считывая память в обратном направлении.
11 | OF (Overflow Flag) | Флаг переполнения. Устанавливается, если знаковые арифметические операции приводят к значению, слишком большому для регистра.

Аппаратные прерывания

Аппаратные прерывания — это сигналы от внешних или внутренних устройств процессору, которые требуют немедленного внимания.

Когда аппаратное устройство (например, таймер или клавиатура) хочет что-то сообщить процессору:

- Оно отправляет аппаратный сигнал прерывания
- Процессор временно приостанавливает выполнение текущей программы
- Переходит к обработчику прерывания (специальной программе)

Как это работает внутри

На системной плате с CPU есть контроллер прерываний, который определяет, какое именно устройство вызвало прерывание.

Каждый тип прерывания связан с уникальным номером (вектором), формируемым контроллером прерываний, и обработчиком в памяти.

Адрес обработчика прерывания вычисляется так:

Смещение обработчика = WORD PTR [Вектор × 4]

Квадратные скобки сообщают нам, что из ячейки памяти размером 1 слово (2 байта или 16 бит) с адресом Вектор × 4 нужно извлечь содержимое, тоже размером 1 слово, и уже его использовать как целевое смещение нужного нам объекта в памяти. В данном случае это будет смещение обработчика прерывания.

Сегмент обработчика = WORD PTR [(Вектор × 4) + 2]

Тот же самый смысл имеют квадратные скобки в случае сегмента: из ячейки памяти размером 1 слово с адресом (Вектор × 4) + 2 извлекаем содержимое и используем его как сегментный адрес обработчика прерывания.

Процедура извлечения из памяти адреса другого участка памяти называется "косвенная адресация". Если вы знакомы с программированием на C, то, возможно, сталкивались с разыменованием указателя. Вот это оно и есть.

При аппаратном прерывании процессор:

- Ждёт завершения текущей исполняемой инструкции
- Сохраняет в стек регистры FLAGS, CS, IP.
- Загружает адрес обработчика из таблицы векторов прерываний в CS:IP.
- Выполняет код обработчика.

После выполнения обработчика команда IRET (interrupt return) возвращает процессор к прерванной задаче, извлекая из стека регистры IP, CS, FLAGS.

Примеры аппаратных прерываний

Номер | Описание
INT 08h | Таймер. По-умолчанию обработчик вызывается каждые ~55 мс
INT 09h | Клавиатура
INT 0Ah-INT 0Fh | Прерывания других периферийных устройств (настраиваются через контроллер PIC)

Программные прерывания — это прерывания, которые инициируются самим кодом программы с помощью специальной инструкции INT.

То есть, мы можем принудительно "прервать" выполнение программы и вызвать системную функцию или собственный обработчик.

Как вызвать программное прерывание?

Очень просто:

```
INT вектор
```

Примеры программных прерываний

Инструкция | Назначение
INT 10h | Работа с видео (BIOS-функции для вывода текста и графики)
INT 13h | Доступ к дисковым устройствам (чтение/запись секторов)
INT 16h | Чтение клавиатуры
INT 21h | DOS-функции: ввод/вывод, работа с файлами

Что происходит при программном прерывании?

Когда процессор выполняет INT xx:

- Он делает примерно то же самое, что при аппаратном прерывании:
- Сохраняет FLAGS, CS, IP в стек.
- Загружает новый CS:IP из таблицы векторов прерываний по номеру прерывания.
- Выполняет код обработчика.

После выполнения обработчика команда IRET (interrupt return) возвращает процессор к прерванной задаче, извлекая из стека регистры IP, CS, FLAGS.

То есть, механизм тот же - отличается только источник сигнала.

## Интересное мнение

На самом деле у Z80 и i8080 только совместимая система команд, а внутри они устроены по разному, вплоть до того что АЛУ у Z80 4-х битное. Плюс Интелу в суде пришлось бы не просто доказывать факт копирования т.к. изменений по сравнению с 8080 было очень много начиная с:
1. Теневого набора регистров
2. Наличие индексных регистров и команд по работе с ними
3. Наличие команд оперирующими битами
4. Более развитая система прерываний
5. Регенерация динамической памяти
6. одно напряжение +5 вольт
7. более высокая производительность
8. возможность адресации 65536 портов ввода/вывода
9. Ассемблер Z80 полностью отличался от ассемблера 8080

А ещё были переходы с относительной адресацией… это было счастье! (когда программируешь в машинных кодах) ))

А еще не упомянули, что и по тактам он был быстрее. Например самую быструю команду MOV 8080 выполнял за 6 тактов, а Z80 за 4 такта, то есть он был еще быстрее чем просто по тактовой частоте считать. И это как-бэ намекает, что его архитектура «не была просто скопирована».

Система команд i8080 очень далека от совершенства, особенно, если рассматривать с точки зрения разработчика компиляторов с языков высокого уровня. По себе могу сказать, что условные возвраты и условные call'ы используются крайне редко. Очень не хватает инструкций смещения стека (add sp,), получения адреса переменной в стеке (lea hl,sp+), загрузка/запись из/в стек по указателю со смещением (ld a,(sp+)), индексации с переменным смещением (ld a,(hl+b)), а так же call hl. Лучше бы вместо условных возвратов, длинных джампов и коллов, они бы сделали: условный относительный переход на 1-9 байт вперед (смещение в коде инструкции), относительный переход на -128...+127, относительный переход на -32768...+32768, абсолютный переход, косвенный переход (на адрес в регистре), относительный call, абсолютный call, косвенный call, а так же инструкции загрузки регистров со смещением (пусть только положительным) относительно PC.
В процессоре gbz80 (который от z80 только мнемоники и таблицу cb имеет) ряд этих инструкций добавлен.
А вот z80 мало что унаследовал весь этот бардак (почему группу загрузок регистр-регистр нельзя было в начало опкодов поместить — тогда бы nop сама собой получилась, push af сохраняет аккумулятор как msb, но при этом он в остальных инструкциях имеет код 7, соответствующий младшему регистру в паре: ld a,a имеет код 0177). Плюс дополнил рядом бесполезных блочных инструкций. Кто-нибудь когда-нибудь использовал otdr и indr? А инструкция neg нахера нужна, когда есть cpl и inc a, исполняющиеся примерно за то же время?
Не так давно Zilog выпустила процессор с расширенным набором команд. Там появились инструкции LEA rr,ii+d и LD rr,(gg). Но Zilog не была бы сама собой, если бы не наворотила глупостей (имхо), например инструкция PEA ii+d (push effective address). Я так и не смог придумать ей полезного применения, а пишу под eZ80 с 2013 года (на z80 стаж с 1993, где-то). А вот реально нужных инструкций не добавилось…

В Z80 и сделали относительный переход +127 -128, и меньше двух байт его не сделаешь, а делать сверхкороткий относительный переход нет смысла из-за нерационального расхода оптокодов.
Необходимость относительного перехода -32768...+32768 вызывает сомнение т.к. 64 кб можно улететь не туда куда надо из-за арифметики.
Косвенный (короткий) вызов подпрограммы, теоретически возможен,, но на практике будет медленнее чем обычный вызов подпрограммы
